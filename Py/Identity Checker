n1 = 256
n2 = 256
print(n1 is n2)
#python usually gives the numbers like the int into the same location
# when we use the is operator then it will compare with the memory location and says true or false

a = int("256")
b = int("256")
print(a is b)

c = -5
d = -5
print(c is d)


e = "gate"
f = "gate"
print(e is f)
#same happens with the strings too
#it will take the same memory location for the small strings

name1 = "Harsha Vardhan"
name2 = "Harsha Vardhan"
print(name1 is name2)

gate1 = "gate2027"
gate2 = "gate"+"2027"
print(gate1 is gate2)

first = "gate2027"
second = "".join(["gate","2027"])
print(first is second)
print(first)
print(second)

g="-6"
h="-6"
print(g is h)

"""
Small positive integers are used constantly: indexing, loops, lengths.
-1 to -5 are also very common (error codes, reverse indexing).

CPython developers chose a range that balances speed and memory.
At interpreter startup, CPython literally pre-creates integer objects:

-5, -4, -3, -2, -1, 0, 1, 2, ... 256

These objects live for the entire program lifetime.

So when you write:

a = -5
b = -5


Python does NOT create two objects.

It simply binds both names to the already-existing cached object.


Usually strings which are the same will be saved into memory.
But even the ones with spaces were accepted. Why?

Python does NOT automatically intern all strings.

It interns:

Identifiers (variable-like names)

Some compile-time literals

Some optimized constants

Strings explicitly interned via sys.intern()

Now look at this:

name1 = "Harsha Vardhan"
name2 = "Harsha Vardhan"


These are two identical string literals inside the same code block.

During compilation, CPython sees:

"Oh, same literal appears twice? I‚Äôll store one object in the constants table."
So both names refer to the same object.
This is not about spaces.
It is about compile-time constant pooling.
The compiler builds a constant table for the code object.
Identical constants often share the same entry.

‚úÖ Compile Time
Happens before execution.

Python:
Parses the code
Builds bytecode
Creates constant table
Performs constant folding
Examples:

x = "gate" + "2027"

The compiler evaluates this immediately and stores:

"gate2027"

So this happens BEFORE your program runs.

‚ùå Run Time

Happens while program is executing.

Example:

x = "".join(["gate", "2027"])

This:
Calls a function
Allocates new memory
Creates new object
This cannot be precomputed because it depends on runtime execution.

How To Distinguish Compile-Time vs Run-Time Creation?

Does this expression contain ONLY constants?

If yes ‚Üí Likely compile-time.

Examples:

"hello" + "world"
2 + 3
(1,2,3)


All constants ‚Üí compiler folds.

üîπ Does it involve:

A function call?
A variable?
User input?
A loop?
A method?

Then ‚Üí Runtime creation.

Example:

a + "world"
"".join([...])
input()

Why is "gate"+"2027" Same but join() Not?

Because:

This:
"gate" + "2027"


Is evaluated by the compiler itself.

But this:

"".join(["gate", "2027"])


Is a function call at runtime.

The compiler cannot assume what .join() does.
So it waits until execution.


In CPython:
Everything is an object.
A variable does NOT store value.
It stores:
reference ‚Üí object in heap

When you say:
a = 5
It means:
a ‚Üí [int object 5]


If that object already exists in cache, Python reuses it.
Otherwise it allocates new memory.






"""